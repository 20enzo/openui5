{"version":3,"file":"chunk-52e7820d.js","sources":["../../../../../../../../../ui5-webcomponents/node_modules/lit-html/lib/directive.js","../../../../../../../../../ui5-webcomponents/node_modules/lit-html/lib/dom.js","../../../../../../../../../ui5-webcomponents/node_modules/lit-html/lib/part.js","../../../../../../../../../ui5-webcomponents/node_modules/lit-html/lib/template.js","../../../../../../../../../ui5-webcomponents/node_modules/lit-html/lib/template-instance.js","../../../../../../../../../ui5-webcomponents/node_modules/lit-html/lib/template-result.js","../../../../../../../../../ui5-webcomponents/node_modules/lit-html/lib/parts.js","../../../../../../../../../ui5-webcomponents/node_modules/lit-html/lib/default-template-processor.js","../../../../../../../../../ui5-webcomponents/node_modules/lit-html/lib/template-factory.js","../../../../../../../../../ui5-webcomponents/node_modules/lit-html/lib/render.js","../../../../../../../../../ui5-webcomponents/node_modules/lit-html/lit-html.js","../../../../../../../../../ui5-webcomponents/packages/base/dist/renderer/scopeHTML.js","../../../../../../../../../ui5-webcomponents/node_modules/lit-html/directives/repeat.js","../../../../../../../../../ui5-webcomponents/node_modules/lit-html/directives/class-map.js","../../../../../../../../../ui5-webcomponents/node_modules/lit-html/directives/style-map.js","../../../../../../../../../ui5-webcomponents/node_modules/lit-html/directives/unsafe-html.js","../../../../../../../../../ui5-webcomponents/packages/base/dist/renderer/LitRenderer.js","../../../../../../../../../ui5-webcomponents/packages/base/dist/renderer/ifDefined.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nconst directives = new WeakMap();\n/**\n * Brands a function as a directive factory function so that lit-html will call\n * the function during template rendering, rather than passing as a value.\n *\n * A _directive_ is a function that takes a Part as an argument. It has the\n * signature: `(part: Part) => void`.\n *\n * A directive _factory_ is a function that takes arguments for data and\n * configuration and returns a directive. Users of directive usually refer to\n * the directive factory as the directive. For example, \"The repeat directive\".\n *\n * Usually a template author will invoke a directive factory in their template\n * with relevant arguments, which will then return a directive function.\n *\n * Here's an example of using the `repeat()` directive factory that takes an\n * array and a function to render an item:\n *\n * ```js\n * html`<ul><${repeat(items, (item) => html`<li>${item}</li>`)}</ul>`\n * ```\n *\n * When `repeat` is invoked, it returns a directive function that closes over\n * `items` and the template function. When the outer template is rendered, the\n * return directive function is called with the Part for the expression.\n * `repeat` then performs it's custom logic to render multiple items.\n *\n * @param f The directive factory function. Must be a function that returns a\n * function of the signature `(part: Part) => void`. The returned function will\n * be called with the part object.\n *\n * @example\n *\n * import {directive, html} from 'lit-html';\n *\n * const immutable = directive((v) => (part) => {\n *   if (part.value !== v) {\n *     part.setValue(v)\n *   }\n * });\n */\nexport const directive = (f) => ((...args) => {\n    const d = f(...args);\n    directives.set(d, true);\n    return d;\n});\nexport const isDirective = (o) => {\n    return typeof o === 'function' && directives.has(o);\n};\n//# sourceMappingURL=directive.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * True if the custom elements polyfill is in use.\n */\nexport const isCEPolyfill = window.customElements !== undefined &&\n    window.customElements.polyfillWrapFlushCallback !==\n        undefined;\n/**\n * Reparents nodes, starting from `start` (inclusive) to `end` (exclusive),\n * into another container (could be the same container), before `before`. If\n * `before` is null, it appends the nodes to the container.\n */\nexport const reparentNodes = (container, start, end = null, before = null) => {\n    while (start !== end) {\n        const n = start.nextSibling;\n        container.insertBefore(start, before);\n        start = n;\n    }\n};\n/**\n * Removes nodes, starting from `start` (inclusive) to `end` (exclusive), from\n * `container`.\n */\nexport const removeNodes = (container, start, end = null) => {\n    while (start !== end) {\n        const n = start.nextSibling;\n        container.removeChild(start);\n        start = n;\n    }\n};\n//# sourceMappingURL=dom.js.map","/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * A sentinel value that signals that a value was handled by a directive and\n * should not be written to the DOM.\n */\nexport const noChange = {};\n/**\n * A sentinel value that signals a NodePart to fully clear its content.\n */\nexport const nothing = {};\n//# sourceMappingURL=part.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * An expression marker with embedded unique key to avoid collision with\n * possible text in templates.\n */\nexport const marker = `{{lit-${String(Math.random()).slice(2)}}}`;\n/**\n * An expression marker used text-positions, multi-binding attributes, and\n * attributes with markup-like text values.\n */\nexport const nodeMarker = `<!--${marker}-->`;\nexport const markerRegex = new RegExp(`${marker}|${nodeMarker}`);\n/**\n * Suffix appended to all bound attribute names.\n */\nexport const boundAttributeSuffix = '$lit$';\n/**\n * An updateable Template that tracks the location of dynamic parts.\n */\nexport class Template {\n    constructor(result, element) {\n        this.parts = [];\n        this.element = element;\n        const nodesToRemove = [];\n        const stack = [];\n        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n        const walker = document.createTreeWalker(element.content, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);\n        // Keeps track of the last index associated with a part. We try to delete\n        // unnecessary nodes, but we never want to associate two different parts\n        // to the same index. They must have a constant node between.\n        let lastPartIndex = 0;\n        let index = -1;\n        let partIndex = 0;\n        const { strings, values: { length } } = result;\n        while (partIndex < length) {\n            const node = walker.nextNode();\n            if (node === null) {\n                // We've exhausted the content inside a nested template element.\n                // Because we still have parts (the outer for-loop), we know:\n                // - There is a template in the stack\n                // - The walker will find a nextNode outside the template\n                walker.currentNode = stack.pop();\n                continue;\n            }\n            index++;\n            if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {\n                if (node.hasAttributes()) {\n                    const attributes = node.attributes;\n                    const { length } = attributes;\n                    // Per\n                    // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,\n                    // attributes are not guaranteed to be returned in document order.\n                    // In particular, Edge/IE can return them out of order, so we cannot\n                    // assume a correspondence between part index and attribute index.\n                    let count = 0;\n                    for (let i = 0; i < length; i++) {\n                        if (endsWith(attributes[i].name, boundAttributeSuffix)) {\n                            count++;\n                        }\n                    }\n                    while (count-- > 0) {\n                        // Get the template literal section leading up to the first\n                        // expression in this attribute\n                        const stringForPart = strings[partIndex];\n                        // Find the attribute name\n                        const name = lastAttributeNameRegex.exec(stringForPart)[2];\n                        // Find the corresponding attribute\n                        // All bound attributes have had a suffix added in\n                        // TemplateResult#getHTML to opt out of special attribute\n                        // handling. To look up the attribute value we also need to add\n                        // the suffix.\n                        const attributeLookupName = name.toLowerCase() + boundAttributeSuffix;\n                        const attributeValue = node.getAttribute(attributeLookupName);\n                        node.removeAttribute(attributeLookupName);\n                        const statics = attributeValue.split(markerRegex);\n                        this.parts.push({ type: 'attribute', index, name, strings: statics });\n                        partIndex += statics.length - 1;\n                    }\n                }\n                if (node.tagName === 'TEMPLATE') {\n                    stack.push(node);\n                    walker.currentNode = node.content;\n                }\n            }\n            else if (node.nodeType === 3 /* Node.TEXT_NODE */) {\n                const data = node.data;\n                if (data.indexOf(marker) >= 0) {\n                    const parent = node.parentNode;\n                    const strings = data.split(markerRegex);\n                    const lastIndex = strings.length - 1;\n                    // Generate a new text node for each literal section\n                    // These nodes are also used as the markers for node parts\n                    for (let i = 0; i < lastIndex; i++) {\n                        let insert;\n                        let s = strings[i];\n                        if (s === '') {\n                            insert = createMarker();\n                        }\n                        else {\n                            const match = lastAttributeNameRegex.exec(s);\n                            if (match !== null && endsWith(match[2], boundAttributeSuffix)) {\n                                s = s.slice(0, match.index) + match[1] +\n                                    match[2].slice(0, -boundAttributeSuffix.length) + match[3];\n                            }\n                            insert = document.createTextNode(s);\n                        }\n                        parent.insertBefore(insert, node);\n                        this.parts.push({ type: 'node', index: ++index });\n                    }\n                    // If there's no text, we must insert a comment to mark our place.\n                    // Else, we can trust it will stick around after cloning.\n                    if (strings[lastIndex] === '') {\n                        parent.insertBefore(createMarker(), node);\n                        nodesToRemove.push(node);\n                    }\n                    else {\n                        node.data = strings[lastIndex];\n                    }\n                    // We have a part for each match found\n                    partIndex += lastIndex;\n                }\n            }\n            else if (node.nodeType === 8 /* Node.COMMENT_NODE */) {\n                if (node.data === marker) {\n                    const parent = node.parentNode;\n                    // Add a new marker node to be the startNode of the Part if any of\n                    // the following are true:\n                    //  * We don't have a previousSibling\n                    //  * The previousSibling is already the start of a previous part\n                    if (node.previousSibling === null || index === lastPartIndex) {\n                        index++;\n                        parent.insertBefore(createMarker(), node);\n                    }\n                    lastPartIndex = index;\n                    this.parts.push({ type: 'node', index });\n                    // If we don't have a nextSibling, keep this node so we have an end.\n                    // Else, we can remove it to save future costs.\n                    if (node.nextSibling === null) {\n                        node.data = '';\n                    }\n                    else {\n                        nodesToRemove.push(node);\n                        index--;\n                    }\n                    partIndex++;\n                }\n                else {\n                    let i = -1;\n                    while ((i = node.data.indexOf(marker, i + 1)) !== -1) {\n                        // Comment node has a binding marker inside, make an inactive part\n                        // The binding won't work, but subsequent bindings will\n                        // TODO (justinfagnani): consider whether it's even worth it to\n                        // make bindings in comments work\n                        this.parts.push({ type: 'node', index: -1 });\n                        partIndex++;\n                    }\n                }\n            }\n        }\n        // Remove text binding nodes after the walk to not disturb the TreeWalker\n        for (const n of nodesToRemove) {\n            n.parentNode.removeChild(n);\n        }\n    }\n}\nconst endsWith = (str, suffix) => {\n    const index = str.length - suffix.length;\n    return index >= 0 && str.slice(index) === suffix;\n};\nexport const isTemplatePartActive = (part) => part.index !== -1;\n// Allows `document.createComment('')` to be renamed for a\n// small manual size-savings.\nexport const createMarker = () => document.createComment('');\n/**\n * This regex extracts the attribute name preceding an attribute-position\n * expression. It does this by matching the syntax allowed for attributes\n * against the string literal directly preceding the expression, assuming that\n * the expression is in an attribute-value position.\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#elements-attributes\n *\n * \" \\x09\\x0a\\x0c\\x0d\" are HTML space characters:\n * https://www.w3.org/TR/html5/infrastructure.html#space-characters\n *\n * \"\\0-\\x1F\\x7F-\\x9F\" are Unicode control characters, which includes every\n * space character except \" \".\n *\n * So an attribute is:\n *  * The name: any character except a control character, space character, ('),\n *    (\"), \">\", \"=\", or \"/\"\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nexport const lastAttributeNameRegex = /([ \\x09\\x0a\\x0c\\x0d])([^\\0-\\x1F\\x7F-\\x9F \"'>=/]+)([ \\x09\\x0a\\x0c\\x0d]*=[ \\x09\\x0a\\x0c\\x0d]*(?:[^ \\x09\\x0a\\x0c\\x0d\"'`<>=]*|\"[^\"]*|'[^']*))$/;\n//# sourceMappingURL=template.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * @module lit-html\n */\nimport { isCEPolyfill } from './dom';\nimport { isTemplatePartActive } from './template';\n/**\n * An instance of a `Template` that can be attached to the DOM and updated\n * with new values.\n */\nexport class TemplateInstance {\n    constructor(template, processor, options) {\n        this.__parts = [];\n        this.template = template;\n        this.processor = processor;\n        this.options = options;\n    }\n    update(values) {\n        let i = 0;\n        for (const part of this.__parts) {\n            if (part !== undefined) {\n                part.setValue(values[i]);\n            }\n            i++;\n        }\n        for (const part of this.__parts) {\n            if (part !== undefined) {\n                part.commit();\n            }\n        }\n    }\n    _clone() {\n        // There are a number of steps in the lifecycle of a template instance's\n        // DOM fragment:\n        //  1. Clone - create the instance fragment\n        //  2. Adopt - adopt into the main document\n        //  3. Process - find part markers and create parts\n        //  4. Upgrade - upgrade custom elements\n        //  5. Update - set node, attribute, property, etc., values\n        //  6. Connect - connect to the document. Optional and outside of this\n        //     method.\n        //\n        // We have a few constraints on the ordering of these steps:\n        //  * We need to upgrade before updating, so that property values will pass\n        //    through any property setters.\n        //  * We would like to process before upgrading so that we're sure that the\n        //    cloned fragment is inert and not disturbed by self-modifying DOM.\n        //  * We want custom elements to upgrade even in disconnected fragments.\n        //\n        // Given these constraints, with full custom elements support we would\n        // prefer the order: Clone, Process, Adopt, Upgrade, Update, Connect\n        //\n        // But Safari dooes not implement CustomElementRegistry#upgrade, so we\n        // can not implement that order and still have upgrade-before-update and\n        // upgrade disconnected fragments. So we instead sacrifice the\n        // process-before-upgrade constraint, since in Custom Elements v1 elements\n        // must not modify their light DOM in the constructor. We still have issues\n        // when co-existing with CEv0 elements like Polymer 1, and with polyfills\n        // that don't strictly adhere to the no-modification rule because shadow\n        // DOM, which may be created in the constructor, is emulated by being placed\n        // in the light DOM.\n        //\n        // The resulting order is on native is: Clone, Adopt, Upgrade, Process,\n        // Update, Connect. document.importNode() performs Clone, Adopt, and Upgrade\n        // in one step.\n        //\n        // The Custom Elements v1 polyfill supports upgrade(), so the order when\n        // polyfilled is the more ideal: Clone, Process, Adopt, Upgrade, Update,\n        // Connect.\n        const fragment = isCEPolyfill ?\n            this.template.element.content.cloneNode(true) :\n            document.importNode(this.template.element.content, true);\n        const stack = [];\n        const parts = this.template.parts;\n        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n        const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);\n        let partIndex = 0;\n        let nodeIndex = 0;\n        let part;\n        let node = walker.nextNode();\n        // Loop through all the nodes and parts of a template\n        while (partIndex < parts.length) {\n            part = parts[partIndex];\n            if (!isTemplatePartActive(part)) {\n                this.__parts.push(undefined);\n                partIndex++;\n                continue;\n            }\n            // Progress the tree walker until we find our next part's node.\n            // Note that multiple parts may share the same node (attribute parts\n            // on a single element), so this loop may not run at all.\n            while (nodeIndex < part.index) {\n                nodeIndex++;\n                if (node.nodeName === 'TEMPLATE') {\n                    stack.push(node);\n                    walker.currentNode = node.content;\n                }\n                if ((node = walker.nextNode()) === null) {\n                    // We've exhausted the content inside a nested template element.\n                    // Because we still have parts (the outer for-loop), we know:\n                    // - There is a template in the stack\n                    // - The walker will find a nextNode outside the template\n                    walker.currentNode = stack.pop();\n                    node = walker.nextNode();\n                }\n            }\n            // We've arrived at our part's node.\n            if (part.type === 'node') {\n                const part = this.processor.handleTextExpression(this.options);\n                part.insertAfterNode(node.previousSibling);\n                this.__parts.push(part);\n            }\n            else {\n                this.__parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));\n            }\n            partIndex++;\n        }\n        if (isCEPolyfill) {\n            document.adoptNode(fragment);\n            customElements.upgrade(fragment);\n        }\n        return fragment;\n    }\n}\n//# sourceMappingURL=template-instance.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * @module lit-html\n */\nimport { reparentNodes } from './dom';\nimport { boundAttributeSuffix, lastAttributeNameRegex, marker, nodeMarker } from './template';\nconst commentMarker = ` ${marker} `;\n/**\n * The return type of `html`, which holds a Template and the values from\n * interpolated expressions.\n */\nexport class TemplateResult {\n    constructor(strings, values, type, processor) {\n        this.strings = strings;\n        this.values = values;\n        this.type = type;\n        this.processor = processor;\n    }\n    /**\n     * Returns a string of HTML used to create a `<template>` element.\n     */\n    getHTML() {\n        const l = this.strings.length - 1;\n        let html = '';\n        let isCommentBinding = false;\n        for (let i = 0; i < l; i++) {\n            const s = this.strings[i];\n            // For each binding we want to determine the kind of marker to insert\n            // into the template source before it's parsed by the browser's HTML\n            // parser. The marker type is based on whether the expression is in an\n            // attribute, text, or comment poisition.\n            //   * For node-position bindings we insert a comment with the marker\n            //     sentinel as its text content, like <!--{{lit-guid}}-->.\n            //   * For attribute bindings we insert just the marker sentinel for the\n            //     first binding, so that we support unquoted attribute bindings.\n            //     Subsequent bindings can use a comment marker because multi-binding\n            //     attributes must be quoted.\n            //   * For comment bindings we insert just the marker sentinel so we don't\n            //     close the comment.\n            //\n            // The following code scans the template source, but is *not* an HTML\n            // parser. We don't need to track the tree structure of the HTML, only\n            // whether a binding is inside a comment, and if not, if it appears to be\n            // the first binding in an attribute.\n            const commentOpen = s.lastIndexOf('<!--');\n            // We're in comment position if we have a comment open with no following\n            // comment close. Because <-- can appear in an attribute value there can\n            // be false positives.\n            isCommentBinding = (commentOpen > -1 || isCommentBinding) &&\n                s.indexOf('-->', commentOpen + 1) === -1;\n            // Check to see if we have an attribute-like sequence preceeding the\n            // expression. This can match \"name=value\" like structures in text,\n            // comments, and attribute values, so there can be false-positives.\n            const attributeMatch = lastAttributeNameRegex.exec(s);\n            if (attributeMatch === null) {\n                // We're only in this branch if we don't have a attribute-like\n                // preceeding sequence. For comments, this guards against unusual\n                // attribute values like <div foo=\"<!--${'bar'}\">. Cases like\n                // <!-- foo=${'bar'}--> are handled correctly in the attribute branch\n                // below.\n                html += s + (isCommentBinding ? commentMarker : nodeMarker);\n            }\n            else {\n                // For attributes we use just a marker sentinel, and also append a\n                // $lit$ suffix to the name to opt-out of attribute-specific parsing\n                // that IE and Edge do for style and certain SVG attributes.\n                html += s.substr(0, attributeMatch.index) + attributeMatch[1] +\n                    attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] +\n                    marker;\n            }\n        }\n        html += this.strings[l];\n        return html;\n    }\n    getTemplateElement() {\n        const template = document.createElement('template');\n        template.innerHTML = this.getHTML();\n        return template;\n    }\n}\n/**\n * A TemplateResult for SVG fragments.\n *\n * This class wraps HTML in an `<svg>` tag in order to parse its contents in the\n * SVG namespace, then modifies the template to remove the `<svg>` tag so that\n * clones only container the original fragment.\n */\nexport class SVGTemplateResult extends TemplateResult {\n    getHTML() {\n        return `<svg>${super.getHTML()}</svg>`;\n    }\n    getTemplateElement() {\n        const template = super.getTemplateElement();\n        const content = template.content;\n        const svgElement = content.firstChild;\n        content.removeChild(svgElement);\n        reparentNodes(content, svgElement.firstChild);\n        return template;\n    }\n}\n//# sourceMappingURL=template-result.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * @module lit-html\n */\nimport { isDirective } from './directive';\nimport { removeNodes } from './dom';\nimport { noChange, nothing } from './part';\nimport { TemplateInstance } from './template-instance';\nimport { TemplateResult } from './template-result';\nimport { createMarker } from './template';\nexport const isPrimitive = (value) => {\n    return (value === null ||\n        !(typeof value === 'object' || typeof value === 'function'));\n};\nexport const isIterable = (value) => {\n    return Array.isArray(value) ||\n        // tslint:disable-next-line:no-any\n        !!(value && value[Symbol.iterator]);\n};\n/**\n * Writes attribute values to the DOM for a group of AttributeParts bound to a\n * single attibute. The value is only set once even if there are multiple parts\n * for an attribute.\n */\nexport class AttributeCommitter {\n    constructor(element, name, strings) {\n        this.dirty = true;\n        this.element = element;\n        this.name = name;\n        this.strings = strings;\n        this.parts = [];\n        for (let i = 0; i < strings.length - 1; i++) {\n            this.parts[i] = this._createPart();\n        }\n    }\n    /**\n     * Creates a single part. Override this to create a differnt type of part.\n     */\n    _createPart() {\n        return new AttributePart(this);\n    }\n    _getValue() {\n        const strings = this.strings;\n        const l = strings.length - 1;\n        let text = '';\n        for (let i = 0; i < l; i++) {\n            text += strings[i];\n            const part = this.parts[i];\n            if (part !== undefined) {\n                const v = part.value;\n                if (isPrimitive(v) || !isIterable(v)) {\n                    text += typeof v === 'string' ? v : String(v);\n                }\n                else {\n                    for (const t of v) {\n                        text += typeof t === 'string' ? t : String(t);\n                    }\n                }\n            }\n        }\n        text += strings[l];\n        return text;\n    }\n    commit() {\n        if (this.dirty) {\n            this.dirty = false;\n            this.element.setAttribute(this.name, this._getValue());\n        }\n    }\n}\n/**\n * A Part that controls all or part of an attribute value.\n */\nexport class AttributePart {\n    constructor(committer) {\n        this.value = undefined;\n        this.committer = committer;\n    }\n    setValue(value) {\n        if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {\n            this.value = value;\n            // If the value is a not a directive, dirty the committer so that it'll\n            // call setAttribute. If the value is a directive, it'll dirty the\n            // committer if it calls setValue().\n            if (!isDirective(value)) {\n                this.committer.dirty = true;\n            }\n        }\n    }\n    commit() {\n        while (isDirective(this.value)) {\n            const directive = this.value;\n            this.value = noChange;\n            directive(this);\n        }\n        if (this.value === noChange) {\n            return;\n        }\n        this.committer.commit();\n    }\n}\n/**\n * A Part that controls a location within a Node tree. Like a Range, NodePart\n * has start and end locations and can set and update the Nodes between those\n * locations.\n *\n * NodeParts support several value types: primitives, Nodes, TemplateResults,\n * as well as arrays and iterables of those types.\n */\nexport class NodePart {\n    constructor(options) {\n        this.value = undefined;\n        this.__pendingValue = undefined;\n        this.options = options;\n    }\n    /**\n     * Appends this part into a container.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    appendInto(container) {\n        this.startNode = container.appendChild(createMarker());\n        this.endNode = container.appendChild(createMarker());\n    }\n    /**\n     * Inserts this part after the `ref` node (between `ref` and `ref`'s next\n     * sibling). Both `ref` and its next sibling must be static, unchanging nodes\n     * such as those that appear in a literal section of a template.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    insertAfterNode(ref) {\n        this.startNode = ref;\n        this.endNode = ref.nextSibling;\n    }\n    /**\n     * Appends this part into a parent part.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    appendIntoPart(part) {\n        part.__insert(this.startNode = createMarker());\n        part.__insert(this.endNode = createMarker());\n    }\n    /**\n     * Inserts this part after the `ref` part.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    insertAfterPart(ref) {\n        ref.__insert(this.startNode = createMarker());\n        this.endNode = ref.endNode;\n        ref.endNode = this.startNode;\n    }\n    setValue(value) {\n        this.__pendingValue = value;\n    }\n    commit() {\n        while (isDirective(this.__pendingValue)) {\n            const directive = this.__pendingValue;\n            this.__pendingValue = noChange;\n            directive(this);\n        }\n        const value = this.__pendingValue;\n        if (value === noChange) {\n            return;\n        }\n        if (isPrimitive(value)) {\n            if (value !== this.value) {\n                this.__commitText(value);\n            }\n        }\n        else if (value instanceof TemplateResult) {\n            this.__commitTemplateResult(value);\n        }\n        else if (value instanceof Node) {\n            this.__commitNode(value);\n        }\n        else if (isIterable(value)) {\n            this.__commitIterable(value);\n        }\n        else if (value === nothing) {\n            this.value = nothing;\n            this.clear();\n        }\n        else {\n            // Fallback, will render the string representation\n            this.__commitText(value);\n        }\n    }\n    __insert(node) {\n        this.endNode.parentNode.insertBefore(node, this.endNode);\n    }\n    __commitNode(value) {\n        if (this.value === value) {\n            return;\n        }\n        this.clear();\n        this.__insert(value);\n        this.value = value;\n    }\n    __commitText(value) {\n        const node = this.startNode.nextSibling;\n        value = value == null ? '' : value;\n        // If `value` isn't already a string, we explicitly convert it here in case\n        // it can't be implicitly converted - i.e. it's a symbol.\n        const valueAsString = typeof value === 'string' ? value : String(value);\n        if (node === this.endNode.previousSibling &&\n            node.nodeType === 3 /* Node.TEXT_NODE */) {\n            // If we only have a single text node between the markers, we can just\n            // set its value, rather than replacing it.\n            // TODO(justinfagnani): Can we just check if this.value is primitive?\n            node.data = valueAsString;\n        }\n        else {\n            this.__commitNode(document.createTextNode(valueAsString));\n        }\n        this.value = value;\n    }\n    __commitTemplateResult(value) {\n        const template = this.options.templateFactory(value);\n        if (this.value instanceof TemplateInstance &&\n            this.value.template === template) {\n            this.value.update(value.values);\n        }\n        else {\n            // Make sure we propagate the template processor from the TemplateResult\n            // so that we use its syntax extension, etc. The template factory comes\n            // from the render function options so that it can control template\n            // caching and preprocessing.\n            const instance = new TemplateInstance(template, value.processor, this.options);\n            const fragment = instance._clone();\n            instance.update(value.values);\n            this.__commitNode(fragment);\n            this.value = instance;\n        }\n    }\n    __commitIterable(value) {\n        // For an Iterable, we create a new InstancePart per item, then set its\n        // value to the item. This is a little bit of overhead for every item in\n        // an Iterable, but it lets us recurse easily and efficiently update Arrays\n        // of TemplateResults that will be commonly returned from expressions like:\n        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n        // If _value is an array, then the previous render was of an\n        // iterable and _value will contain the NodeParts from the previous\n        // render. If _value is not an array, clear this part and make a new\n        // array for NodeParts.\n        if (!Array.isArray(this.value)) {\n            this.value = [];\n            this.clear();\n        }\n        // Lets us keep track of how many items we stamped so we can clear leftover\n        // items from a previous render\n        const itemParts = this.value;\n        let partIndex = 0;\n        let itemPart;\n        for (const item of value) {\n            // Try to reuse an existing part\n            itemPart = itemParts[partIndex];\n            // If no existing part, create a new one\n            if (itemPart === undefined) {\n                itemPart = new NodePart(this.options);\n                itemParts.push(itemPart);\n                if (partIndex === 0) {\n                    itemPart.appendIntoPart(this);\n                }\n                else {\n                    itemPart.insertAfterPart(itemParts[partIndex - 1]);\n                }\n            }\n            itemPart.setValue(item);\n            itemPart.commit();\n            partIndex++;\n        }\n        if (partIndex < itemParts.length) {\n            // Truncate the parts array so _value reflects the current state\n            itemParts.length = partIndex;\n            this.clear(itemPart && itemPart.endNode);\n        }\n    }\n    clear(startNode = this.startNode) {\n        removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);\n    }\n}\n/**\n * Implements a boolean attribute, roughly as defined in the HTML\n * specification.\n *\n * If the value is truthy, then the attribute is present with a value of\n * ''. If the value is falsey, the attribute is removed.\n */\nexport class BooleanAttributePart {\n    constructor(element, name, strings) {\n        this.value = undefined;\n        this.__pendingValue = undefined;\n        if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {\n            throw new Error('Boolean attributes can only contain a single expression');\n        }\n        this.element = element;\n        this.name = name;\n        this.strings = strings;\n    }\n    setValue(value) {\n        this.__pendingValue = value;\n    }\n    commit() {\n        while (isDirective(this.__pendingValue)) {\n            const directive = this.__pendingValue;\n            this.__pendingValue = noChange;\n            directive(this);\n        }\n        if (this.__pendingValue === noChange) {\n            return;\n        }\n        const value = !!this.__pendingValue;\n        if (this.value !== value) {\n            if (value) {\n                this.element.setAttribute(this.name, '');\n            }\n            else {\n                this.element.removeAttribute(this.name);\n            }\n            this.value = value;\n        }\n        this.__pendingValue = noChange;\n    }\n}\n/**\n * Sets attribute values for PropertyParts, so that the value is only set once\n * even if there are multiple parts for a property.\n *\n * If an expression controls the whole property value, then the value is simply\n * assigned to the property under control. If there are string literals or\n * multiple expressions, then the strings are expressions are interpolated into\n * a string first.\n */\nexport class PropertyCommitter extends AttributeCommitter {\n    constructor(element, name, strings) {\n        super(element, name, strings);\n        this.single =\n            (strings.length === 2 && strings[0] === '' && strings[1] === '');\n    }\n    _createPart() {\n        return new PropertyPart(this);\n    }\n    _getValue() {\n        if (this.single) {\n            return this.parts[0].value;\n        }\n        return super._getValue();\n    }\n    commit() {\n        if (this.dirty) {\n            this.dirty = false;\n            // tslint:disable-next-line:no-any\n            this.element[this.name] = this._getValue();\n        }\n    }\n}\nexport class PropertyPart extends AttributePart {\n}\n// Detect event listener options support. If the `capture` property is read\n// from the options object, then options are supported. If not, then the thrid\n// argument to add/removeEventListener is interpreted as the boolean capture\n// value so we should only pass the `capture` property.\nlet eventOptionsSupported = false;\ntry {\n    const options = {\n        get capture() {\n            eventOptionsSupported = true;\n            return false;\n        }\n    };\n    // tslint:disable-next-line:no-any\n    window.addEventListener('test', options, options);\n    // tslint:disable-next-line:no-any\n    window.removeEventListener('test', options, options);\n}\ncatch (_e) {\n}\nexport class EventPart {\n    constructor(element, eventName, eventContext) {\n        this.value = undefined;\n        this.__pendingValue = undefined;\n        this.element = element;\n        this.eventName = eventName;\n        this.eventContext = eventContext;\n        this.__boundHandleEvent = (e) => this.handleEvent(e);\n    }\n    setValue(value) {\n        this.__pendingValue = value;\n    }\n    commit() {\n        while (isDirective(this.__pendingValue)) {\n            const directive = this.__pendingValue;\n            this.__pendingValue = noChange;\n            directive(this);\n        }\n        if (this.__pendingValue === noChange) {\n            return;\n        }\n        const newListener = this.__pendingValue;\n        const oldListener = this.value;\n        const shouldRemoveListener = newListener == null ||\n            oldListener != null &&\n                (newListener.capture !== oldListener.capture ||\n                    newListener.once !== oldListener.once ||\n                    newListener.passive !== oldListener.passive);\n        const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);\n        if (shouldRemoveListener) {\n            this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);\n        }\n        if (shouldAddListener) {\n            this.__options = getOptions(newListener);\n            this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);\n        }\n        this.value = newListener;\n        this.__pendingValue = noChange;\n    }\n    handleEvent(event) {\n        if (typeof this.value === 'function') {\n            this.value.call(this.eventContext || this.element, event);\n        }\n        else {\n            this.value.handleEvent(event);\n        }\n    }\n}\n// We copy options because of the inconsistent behavior of browsers when reading\n// the third argument of add/removeEventListener. IE11 doesn't support options\n// at all. Chrome 41 only reads `capture` if the argument is an object.\nconst getOptions = (o) => o &&\n    (eventOptionsSupported ?\n        { capture: o.capture, passive: o.passive, once: o.once } :\n        o.capture);\n//# sourceMappingURL=parts.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { AttributeCommitter, BooleanAttributePart, EventPart, NodePart, PropertyCommitter } from './parts';\n/**\n * Creates Parts when a template is instantiated.\n */\nexport class DefaultTemplateProcessor {\n    /**\n     * Create parts for an attribute-position binding, given the event, attribute\n     * name, and string literals.\n     *\n     * @param element The element containing the binding\n     * @param name  The attribute name\n     * @param strings The string literals. There are always at least two strings,\n     *   event for fully-controlled bindings with a single expression.\n     */\n    handleAttributeExpressions(element, name, strings, options) {\n        const prefix = name[0];\n        if (prefix === '.') {\n            const committer = new PropertyCommitter(element, name.slice(1), strings);\n            return committer.parts;\n        }\n        if (prefix === '@') {\n            return [new EventPart(element, name.slice(1), options.eventContext)];\n        }\n        if (prefix === '?') {\n            return [new BooleanAttributePart(element, name.slice(1), strings)];\n        }\n        const committer = new AttributeCommitter(element, name, strings);\n        return committer.parts;\n    }\n    /**\n     * Create parts for a text-position binding.\n     * @param templateFactory\n     */\n    handleTextExpression(options) {\n        return new NodePart(options);\n    }\n}\nexport const defaultTemplateProcessor = new DefaultTemplateProcessor();\n//# sourceMappingURL=default-template-processor.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { marker, Template } from './template';\n/**\n * The default TemplateFactory which caches Templates keyed on\n * result.type and result.strings.\n */\nexport function templateFactory(result) {\n    let templateCache = templateCaches.get(result.type);\n    if (templateCache === undefined) {\n        templateCache = {\n            stringsArray: new WeakMap(),\n            keyString: new Map()\n        };\n        templateCaches.set(result.type, templateCache);\n    }\n    let template = templateCache.stringsArray.get(result.strings);\n    if (template !== undefined) {\n        return template;\n    }\n    // If the TemplateStringsArray is new, generate a key from the strings\n    // This key is shared between all templates with identical content\n    const key = result.strings.join(marker);\n    // Check if we already have a Template for this key\n    template = templateCache.keyString.get(key);\n    if (template === undefined) {\n        // If we have not seen this key before, create a new Template\n        template = new Template(result, result.getTemplateElement());\n        // Cache the Template for this key\n        templateCache.keyString.set(key, template);\n    }\n    // Cache all future queries for this TemplateStringsArray\n    templateCache.stringsArray.set(result.strings, template);\n    return template;\n}\nexport const templateCaches = new Map();\n//# sourceMappingURL=template-factory.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * @module lit-html\n */\nimport { removeNodes } from './dom';\nimport { NodePart } from './parts';\nimport { templateFactory } from './template-factory';\nexport const parts = new WeakMap();\n/**\n * Renders a template result or other value to a container.\n *\n * To update a container with new values, reevaluate the template literal and\n * call `render` with the new result.\n *\n * @param result Any value renderable by NodePart - typically a TemplateResult\n *     created by evaluating a template tag like `html` or `svg`.\n * @param container A DOM parent to render to. The entire contents are either\n *     replaced, or efficiently updated if the same result type was previous\n *     rendered there.\n * @param options RenderOptions for the entire render tree rendered to this\n *     container. Render options must *not* change between renders to the same\n *     container, as those changes will not effect previously rendered DOM.\n */\nexport const render = (result, container, options) => {\n    let part = parts.get(container);\n    if (part === undefined) {\n        removeNodes(container, container.firstChild);\n        parts.set(container, part = new NodePart(Object.assign({ templateFactory }, options)));\n        part.appendInto(container);\n    }\n    part.setValue(result);\n    part.commit();\n};\n//# sourceMappingURL=render.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n *\n * Main lit-html module.\n *\n * Main exports:\n *\n * -  [[html]]\n * -  [[svg]]\n * -  [[render]]\n *\n * @module lit-html\n * @preferred\n */\n/**\n * Do not remove this comment; it keeps typedoc from misplacing the module\n * docs.\n */\nimport { defaultTemplateProcessor } from './lib/default-template-processor';\nimport { SVGTemplateResult, TemplateResult } from './lib/template-result';\nexport { DefaultTemplateProcessor, defaultTemplateProcessor } from './lib/default-template-processor';\nexport { directive, isDirective } from './lib/directive';\n// TODO(justinfagnani): remove line when we get NodePart moving methods\nexport { removeNodes, reparentNodes } from './lib/dom';\nexport { noChange, nothing } from './lib/part';\nexport { AttributeCommitter, AttributePart, BooleanAttributePart, EventPart, isIterable, isPrimitive, NodePart, PropertyCommitter, PropertyPart } from './lib/parts';\nexport { parts, render } from './lib/render';\nexport { templateCaches, templateFactory } from './lib/template-factory';\nexport { TemplateInstance } from './lib/template-instance';\nexport { SVGTemplateResult, TemplateResult } from './lib/template-result';\nexport { createMarker, isTemplatePartActive, Template } from './lib/template';\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for lit-html usage.\n// TODO(justinfagnani): inject version number at build time\n(window['litHtmlVersions'] || (window['litHtmlVersions'] = [])).push('1.1.2');\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nexport const html = (strings, ...values) => new TemplateResult(strings, values, 'html', defaultTemplateProcessor);\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nexport const svg = (strings, ...values) => new SVGTemplateResult(strings, values, 'svg', defaultTemplateProcessor);\n//# sourceMappingURL=lit-html.js.map","const cache = new Map();\n\nconst scopeHTML = (strings, tags, suffix) => {\n\tif (suffix && tags && tags.length) {\n\t\tstrings = strings.map(string => {\n\t\t\tif (cache.has(string)) {\n\t\t\t\treturn cache.get(string);\n\t\t\t}\n\n\t\t\t/*\n\t\t\tconst allTags = [...string.matchAll(/<(ui5-.*?)[> ]/g)].map(x => x[1]);\n\t\t\tallTags.forEach(t => {\n\t\t\t\tif (!tags.includes(t)) {\n\t\t\t\t\tthrow new Error(`${t} not found in ${string}`);\n\t\t\t\t\t// console.log(t, \" in \", string);\n\t\t\t\t}\n\t\t\t});\n\t\t\t*/\n\n\t\t\tlet result = string;\n\t\t\ttags.forEach(tag => {\n\t\t\t\tresult = result.replace(new RegExp(`(</?)(${tag})(/?[> \\t\\n])`, \"g\"), `$1$2-${suffix}$3`);\n\t\t\t});\n\t\t\tcache.set(string, result);\n\t\t\treturn result;\n\t\t});\n\t}\n\n\treturn strings;\n};\n\nexport default scopeHTML;\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { createMarker, directive, NodePart, removeNodes, reparentNodes } from '../lit-html';\n// Helper functions for manipulating parts\n// TODO(kschaaf): Refactor into Part API?\nconst createAndInsertPart = (containerPart, beforePart) => {\n    const container = containerPart.startNode.parentNode;\n    const beforeNode = beforePart === undefined ? containerPart.endNode :\n        beforePart.startNode;\n    const startNode = container.insertBefore(createMarker(), beforeNode);\n    container.insertBefore(createMarker(), beforeNode);\n    const newPart = new NodePart(containerPart.options);\n    newPart.insertAfterNode(startNode);\n    return newPart;\n};\nconst updatePart = (part, value) => {\n    part.setValue(value);\n    part.commit();\n    return part;\n};\nconst insertPartBefore = (containerPart, part, ref) => {\n    const container = containerPart.startNode.parentNode;\n    const beforeNode = ref ? ref.startNode : containerPart.endNode;\n    const endNode = part.endNode.nextSibling;\n    if (endNode !== beforeNode) {\n        reparentNodes(container, part.startNode, endNode, beforeNode);\n    }\n};\nconst removePart = (part) => {\n    removeNodes(part.startNode.parentNode, part.startNode, part.endNode.nextSibling);\n};\n// Helper for generating a map of array item to its index over a subset\n// of an array (used to lazily generate `newKeyToIndexMap` and\n// `oldKeyToIndexMap`)\nconst generateMap = (list, start, end) => {\n    const map = new Map();\n    for (let i = start; i <= end; i++) {\n        map.set(list[i], i);\n    }\n    return map;\n};\n// Stores previous ordered list of parts and map of key to index\nconst partListCache = new WeakMap();\nconst keyListCache = new WeakMap();\n/**\n * A directive that repeats a series of values (usually `TemplateResults`)\n * generated from an iterable, and updates those items efficiently when the\n * iterable changes based on user-provided `keys` associated with each item.\n *\n * Note that if a `keyFn` is provided, strict key-to-DOM mapping is maintained,\n * meaning previous DOM for a given key is moved into the new position if\n * needed, and DOM will never be reused with values for different keys (new DOM\n * will always be created for new keys). This is generally the most efficient\n * way to use `repeat` since it performs minimum unnecessary work for insertions\n * amd removals.\n *\n * IMPORTANT: If providing a `keyFn`, keys *must* be unique for all items in a\n * given call to `repeat`. The behavior when two or more items have the same key\n * is undefined.\n *\n * If no `keyFn` is provided, this directive will perform similar to mapping\n * items to values, and DOM will be reused against potentially different items.\n */\nexport const repeat = directive((items, keyFnOrTemplate, template) => {\n    let keyFn;\n    if (template === undefined) {\n        template = keyFnOrTemplate;\n    }\n    else if (keyFnOrTemplate !== undefined) {\n        keyFn = keyFnOrTemplate;\n    }\n    return (containerPart) => {\n        if (!(containerPart instanceof NodePart)) {\n            throw new Error('repeat can only be used in text bindings');\n        }\n        // Old part & key lists are retrieved from the last update\n        // (associated with the part for this instance of the directive)\n        const oldParts = partListCache.get(containerPart) || [];\n        const oldKeys = keyListCache.get(containerPart) || [];\n        // New part list will be built up as we go (either reused from\n        // old parts or created for new keys in this update). This is\n        // saved in the above cache at the end of the update.\n        const newParts = [];\n        // New value list is eagerly generated from items along with a\n        // parallel array indicating its key.\n        const newValues = [];\n        const newKeys = [];\n        let index = 0;\n        for (const item of items) {\n            newKeys[index] = keyFn ? keyFn(item, index) : index;\n            newValues[index] = template(item, index);\n            index++;\n        }\n        // Maps from key to index for current and previous update; these\n        // are generated lazily only when needed as a performance\n        // optimization, since they are only required for multiple\n        // non-contiguous changes in the list, which are less common.\n        let newKeyToIndexMap;\n        let oldKeyToIndexMap;\n        // Head and tail pointers to old parts and new values\n        let oldHead = 0;\n        let oldTail = oldParts.length - 1;\n        let newHead = 0;\n        let newTail = newValues.length - 1;\n        // Overview of O(n) reconciliation algorithm (general approach\n        // based on ideas found in ivi, vue, snabbdom, etc.):\n        //\n        // * We start with the list of old parts and new values (and\n        //   arrays of their respective keys), head/tail pointers into\n        //   each, and we build up the new list of parts by updating\n        //   (and when needed, moving) old parts or creating new ones.\n        //   The initial scenario might look like this (for brevity of\n        //   the diagrams, the numbers in the array reflect keys\n        //   associated with the old parts or new values, although keys\n        //   and parts/values are actually stored in parallel arrays\n        //   indexed using the same head/tail pointers):\n        //\n        //      oldHead v                 v oldTail\n        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n        //   newParts: [ ,  ,  ,  ,  ,  ,  ]\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6] <- reflects the user's new\n        //                                      item order\n        //      newHead ^                 ^ newTail\n        //\n        // * Iterate old & new lists from both sides, updating,\n        //   swapping, or removing parts at the head/tail locations\n        //   until neither head nor tail can move.\n        //\n        // * Example below: keys at head pointers match, so update old\n        //   part 0 in-place (no need to move it) and record part 0 in\n        //   the `newParts` list. The last thing we do is advance the\n        //   `oldHead` and `newHead` pointers (will be reflected in the\n        //   next diagram).\n        //\n        //      oldHead v                 v oldTail\n        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n        //   newParts: [0,  ,  ,  ,  ,  ,  ] <- heads matched: update 0\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead\n        //                                      & newHead\n        //      newHead ^                 ^ newTail\n        //\n        // * Example below: head pointers don't match, but tail\n        //   pointers do, so update part 6 in place (no need to move\n        //   it), and record part 6 in the `newParts` list. Last,\n        //   advance the `oldTail` and `oldHead` pointers.\n        //\n        //         oldHead v              v oldTail\n        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n        //   newParts: [0,  ,  ,  ,  ,  , 6] <- tails matched: update 6\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldTail\n        //                                      & newTail\n        //         newHead ^              ^ newTail\n        //\n        // * If neither head nor tail match; next check if one of the\n        //   old head/tail items was removed. We first need to generate\n        //   the reverse map of new keys to index (`newKeyToIndexMap`),\n        //   which is done once lazily as a performance optimization,\n        //   since we only hit this case if multiple non-contiguous\n        //   changes were made. Note that for contiguous removal\n        //   anywhere in the list, the head and tails would advance\n        //   from either end and pass each other before we get to this\n        //   case and removals would be handled in the final while loop\n        //   without needing to generate the map.\n        //\n        // * Example below: The key at `oldTail` was removed (no longer\n        //   in the `newKeyToIndexMap`), so remove that part from the\n        //   DOM and advance just the `oldTail` pointer.\n        //\n        //         oldHead v           v oldTail\n        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n        //   newParts: [0,  ,  ,  ,  ,  , 6] <- 5 not in new map: remove\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    5 and advance oldTail\n        //         newHead ^           ^ newTail\n        //\n        // * Once head and tail cannot move, any mismatches are due to\n        //   either new or moved items; if a new key is in the previous\n        //   \"old key to old index\" map, move the old part to the new\n        //   location, otherwise create and insert a new part. Note\n        //   that when moving an old part we null its position in the\n        //   oldParts array if it lies between the head and tail so we\n        //   know to skip it when the pointers get there.\n        //\n        // * Example below: neither head nor tail match, and neither\n        //   were removed; so find the `newHead` key in the\n        //   `oldKeyToIndexMap`, and move that old part's DOM into the\n        //   next head position (before `oldParts[oldHead]`). Last,\n        //   null the part in the `oldPart` array since it was\n        //   somewhere in the remaining oldParts still to be scanned\n        //   (between the head and tail pointers) so that we know to\n        //   skip that old part on future iterations.\n        //\n        //         oldHead v        v oldTail\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n        //   newParts: [0, 2,  ,  ,  ,  , 6] <- stuck: update & move 2\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    into place and advance\n        //                                      newHead\n        //         newHead ^           ^ newTail\n        //\n        // * Note that for moves/insertions like the one above, a part\n        //   inserted at the head pointer is inserted before the\n        //   current `oldParts[oldHead]`, and a part inserted at the\n        //   tail pointer is inserted before `newParts[newTail+1]`. The\n        //   seeming asymmetry lies in the fact that new parts are\n        //   moved into place outside in, so to the right of the head\n        //   pointer are old parts, and to the right of the tail\n        //   pointer are new parts.\n        //\n        // * We always restart back from the top of the algorithm,\n        //   allowing matching and simple updates in place to\n        //   continue...\n        //\n        // * Example below: the head pointers once again match, so\n        //   simply update part 1 and record it in the `newParts`\n        //   array.  Last, advance both head pointers.\n        //\n        //         oldHead v        v oldTail\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n        //   newParts: [0, 2, 1,  ,  ,  , 6] <- heads matched: update 1\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead\n        //                                      & newHead\n        //            newHead ^        ^ newTail\n        //\n        // * As mentioned above, items that were moved as a result of\n        //   being stuck (the final else clause in the code below) are\n        //   marked with null, so we always advance old pointers over\n        //   these so we're comparing the next actual old value on\n        //   either end.\n        //\n        // * Example below: `oldHead` is null (already placed in\n        //   newParts), so advance `oldHead`.\n        //\n        //            oldHead v     v oldTail\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6] <- old head already used:\n        //   newParts: [0, 2, 1,  ,  ,  , 6]    advance oldHead\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n        //               newHead ^     ^ newTail\n        //\n        // * Note it's not critical to mark old parts as null when they\n        //   are moved from head to tail or tail to head, since they\n        //   will be outside the pointer range and never visited again.\n        //\n        // * Example below: Here the old tail key matches the new head\n        //   key, so the part at the `oldTail` position and move its\n        //   DOM to the new head position (before `oldParts[oldHead]`).\n        //   Last, advance `oldTail` and `newHead` pointers.\n        //\n        //               oldHead v  v oldTail\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n        //   newParts: [0, 2, 1, 4,  ,  , 6] <- old tail matches new\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]   head: update & move 4,\n        //                                     advance oldTail & newHead\n        //               newHead ^     ^ newTail\n        //\n        // * Example below: Old and new head keys match, so update the\n        //   old head part in place, and advance the `oldHead` and\n        //   `newHead` pointers.\n        //\n        //               oldHead v oldTail\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n        //   newParts: [0, 2, 1, 4, 3,   ,6] <- heads match: update 3\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance oldHead &\n        //                                      newHead\n        //                  newHead ^  ^ newTail\n        //\n        // * Once the new or old pointers move past each other then all\n        //   we have left is additions (if old list exhausted) or\n        //   removals (if new list exhausted). Those are handled in the\n        //   final while loops at the end.\n        //\n        // * Example below: `oldHead` exceeded `oldTail`, so we're done\n        //   with the main loop.  Create the remaining part and insert\n        //   it at the new head position, and the update is complete.\n        //\n        //                   (oldHead > oldTail)\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n        //   newParts: [0, 2, 1, 4, 3, 7 ,6] <- create and insert 7\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n        //                     newHead ^ newTail\n        //\n        // * Note that the order of the if/else clauses is not\n        //   important to the algorithm, as long as the null checks\n        //   come first (to ensure we're always working on valid old\n        //   parts) and that the final else clause comes last (since\n        //   that's where the expensive moves occur). The order of\n        //   remaining clauses is is just a simple guess at which cases\n        //   will be most common.\n        //\n        // * TODO(kschaaf) Note, we could calculate the longest\n        //   increasing subsequence (LIS) of old items in new position,\n        //   and only move those not in the LIS set. However that costs\n        //   O(nlogn) time and adds a bit more code, and only helps\n        //   make rare types of mutations require fewer moves. The\n        //   above handles removes, adds, reversal, swaps, and single\n        //   moves of contiguous items in linear time, in the minimum\n        //   number of moves. As the number of multiple moves where LIS\n        //   might help approaches a random shuffle, the LIS\n        //   optimization becomes less helpful, so it seems not worth\n        //   the code at this point. Could reconsider if a compelling\n        //   case arises.\n        while (oldHead <= oldTail && newHead <= newTail) {\n            if (oldParts[oldHead] === null) {\n                // `null` means old part at head has already been used\n                // below; skip\n                oldHead++;\n            }\n            else if (oldParts[oldTail] === null) {\n                // `null` means old part at tail has already been used\n                // below; skip\n                oldTail--;\n            }\n            else if (oldKeys[oldHead] === newKeys[newHead]) {\n                // Old head matches new head; update in place\n                newParts[newHead] =\n                    updatePart(oldParts[oldHead], newValues[newHead]);\n                oldHead++;\n                newHead++;\n            }\n            else if (oldKeys[oldTail] === newKeys[newTail]) {\n                // Old tail matches new tail; update in place\n                newParts[newTail] =\n                    updatePart(oldParts[oldTail], newValues[newTail]);\n                oldTail--;\n                newTail--;\n            }\n            else if (oldKeys[oldHead] === newKeys[newTail]) {\n                // Old head matches new tail; update and move to new tail\n                newParts[newTail] =\n                    updatePart(oldParts[oldHead], newValues[newTail]);\n                insertPartBefore(containerPart, oldParts[oldHead], newParts[newTail + 1]);\n                oldHead++;\n                newTail--;\n            }\n            else if (oldKeys[oldTail] === newKeys[newHead]) {\n                // Old tail matches new head; update and move to new head\n                newParts[newHead] =\n                    updatePart(oldParts[oldTail], newValues[newHead]);\n                insertPartBefore(containerPart, oldParts[oldTail], oldParts[oldHead]);\n                oldTail--;\n                newHead++;\n            }\n            else {\n                if (newKeyToIndexMap === undefined) {\n                    // Lazily generate key-to-index maps, used for removals &\n                    // moves below\n                    newKeyToIndexMap = generateMap(newKeys, newHead, newTail);\n                    oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);\n                }\n                if (!newKeyToIndexMap.has(oldKeys[oldHead])) {\n                    // Old head is no longer in new list; remove\n                    removePart(oldParts[oldHead]);\n                    oldHead++;\n                }\n                else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {\n                    // Old tail is no longer in new list; remove\n                    removePart(oldParts[oldTail]);\n                    oldTail--;\n                }\n                else {\n                    // Any mismatches at this point are due to additions or\n                    // moves; see if we have an old part we can reuse and move\n                    // into place\n                    const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);\n                    const oldPart = oldIndex !== undefined ? oldParts[oldIndex] : null;\n                    if (oldPart === null) {\n                        // No old part for this value; create a new one and\n                        // insert it\n                        const newPart = createAndInsertPart(containerPart, oldParts[oldHead]);\n                        updatePart(newPart, newValues[newHead]);\n                        newParts[newHead] = newPart;\n                    }\n                    else {\n                        // Reuse old part\n                        newParts[newHead] =\n                            updatePart(oldPart, newValues[newHead]);\n                        insertPartBefore(containerPart, oldPart, oldParts[oldHead]);\n                        // This marks the old part as having been used, so that\n                        // it will be skipped in the first two checks above\n                        oldParts[oldIndex] = null;\n                    }\n                    newHead++;\n                }\n            }\n        }\n        // Add parts for any remaining new values\n        while (newHead <= newTail) {\n            // For all remaining additions, we insert before last new\n            // tail, since old pointers are no longer valid\n            const newPart = createAndInsertPart(containerPart, newParts[newTail + 1]);\n            updatePart(newPart, newValues[newHead]);\n            newParts[newHead++] = newPart;\n        }\n        // Remove any remaining unused old parts\n        while (oldHead <= oldTail) {\n            const oldPart = oldParts[oldHead++];\n            if (oldPart !== null) {\n                removePart(oldPart);\n            }\n        }\n        // Save order of new parts for next round\n        partListCache.set(containerPart, newParts);\n        keyListCache.set(containerPart, newKeys);\n    };\n});\n//# sourceMappingURL=repeat.js.map","/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { AttributePart, directive, PropertyPart } from '../lit-html';\n/**\n * Stores the ClassInfo object applied to a given AttributePart.\n * Used to unset existing values when a new ClassInfo object is applied.\n */\nconst classMapCache = new WeakMap();\n/**\n * A directive that applies CSS classes. This must be used in the `class`\n * attribute and must be the only part used in the attribute. It takes each\n * property in the `classInfo` argument and adds the property name to the\n * element's `classList` if the property value is truthy; if the property value\n * is falsey, the property name is removed from the element's `classList`. For\n * example\n * `{foo: bar}` applies the class `foo` if the value of `bar` is truthy.\n * @param classInfo {ClassInfo}\n */\nexport const classMap = directive((classInfo) => (part) => {\n    if (!(part instanceof AttributePart) || (part instanceof PropertyPart) ||\n        part.committer.name !== 'class' || part.committer.parts.length > 1) {\n        throw new Error('The `classMap` directive must be used in the `class` attribute ' +\n            'and must be the only part in the attribute.');\n    }\n    const { committer } = part;\n    const { element } = committer;\n    // handle static classes\n    if (!classMapCache.has(part)) {\n        element.className = committer.strings.join(' ');\n    }\n    const { classList } = element;\n    // remove old classes that no longer apply\n    const oldInfo = classMapCache.get(part);\n    for (const name in oldInfo) {\n        if (!(name in classInfo)) {\n            classList.remove(name);\n        }\n    }\n    // add new classes\n    for (const name in classInfo) {\n        const value = classInfo[name];\n        if (!oldInfo || value !== oldInfo[name]) {\n            // We explicitly want a loose truthy check here because\n            // it seems more convenient that '' and 0 are skipped.\n            const method = value ? 'add' : 'remove';\n            classList[method](name);\n        }\n    }\n    classMapCache.set(part, classInfo);\n});\n//# sourceMappingURL=class-map.js.map","/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { AttributePart, directive, PropertyPart } from '../lit-html';\n/**\n * Stores the StyleInfo object applied to a given AttributePart.\n * Used to unset existing values when a new StyleInfo object is applied.\n */\nconst styleMapCache = new WeakMap();\n/**\n * A directive that applies CSS properties to an element.\n *\n * `styleMap` can only be used in the `style` attribute and must be the only\n * expression in the attribute. It takes the property names in the `styleInfo`\n * object and adds the property values as CSS propertes. Property names with\n * dashes (`-`) are assumed to be valid CSS property names and set on the\n * element's style object using `setProperty()`. Names without dashes are\n * assumed to be camelCased JavaScript property names and set on the element's\n * style object using property assignment, allowing the style object to\n * translate JavaScript-style names to CSS property names.\n *\n * For example `styleMap({backgroundColor: 'red', 'border-top': '5px', '--size':\n * '0'})` sets the `background-color`, `border-top` and `--size` properties.\n *\n * @param styleInfo {StyleInfo}\n */\nexport const styleMap = directive((styleInfo) => (part) => {\n    if (!(part instanceof AttributePart) || (part instanceof PropertyPart) ||\n        part.committer.name !== 'style' || part.committer.parts.length > 1) {\n        throw new Error('The `styleMap` directive must be used in the style attribute ' +\n            'and must be the only part in the attribute.');\n    }\n    const { committer } = part;\n    const { style } = committer.element;\n    // Handle static styles the first time we see a Part\n    if (!styleMapCache.has(part)) {\n        style.cssText = committer.strings.join(' ');\n    }\n    // Remove old properties that no longer exist in styleInfo\n    const oldInfo = styleMapCache.get(part);\n    for (const name in oldInfo) {\n        if (!(name in styleInfo)) {\n            if (name.indexOf('-') === -1) {\n                // tslint:disable-next-line:no-any\n                style[name] = null;\n            }\n            else {\n                style.removeProperty(name);\n            }\n        }\n    }\n    // Add or update properties\n    for (const name in styleInfo) {\n        if (name.indexOf('-') === -1) {\n            // tslint:disable-next-line:no-any\n            style[name] = styleInfo[name];\n        }\n        else {\n            style.setProperty(name, styleInfo[name]);\n        }\n    }\n    styleMapCache.set(part, styleInfo);\n});\n//# sourceMappingURL=style-map.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { isPrimitive } from '../lib/parts';\nimport { directive, NodePart } from '../lit-html';\n// For each part, remember the value that was last rendered to the part by the\n// unsafeHTML directive, and the DocumentFragment that was last set as a value.\n// The DocumentFragment is used as a unique key to check if the last value\n// rendered to the part was with unsafeHTML. If not, we'll always re-render the\n// value passed to unsafeHTML.\nconst previousValues = new WeakMap();\n/**\n * Renders the result as HTML, rather than text.\n *\n * Note, this is unsafe to use with any user-provided input that hasn't been\n * sanitized or escaped, as it may lead to cross-site-scripting\n * vulnerabilities.\n */\nexport const unsafeHTML = directive((value) => (part) => {\n    if (!(part instanceof NodePart)) {\n        throw new Error('unsafeHTML can only be used in text bindings');\n    }\n    const previousValue = previousValues.get(part);\n    if (previousValue !== undefined && isPrimitive(value) &&\n        value === previousValue.value && part.value === previousValue.fragment) {\n        return;\n    }\n    const template = document.createElement('template');\n    template.innerHTML = value; // innerHTML casts to string internally\n    const fragment = document.importNode(template.content, true);\n    part.setValue(fragment);\n    previousValues.set(part, { value, fragment });\n});\n//# sourceMappingURL=unsafe-html.js.map","import { html, svg, render } from \"lit-html/lit-html.js\";\nimport scopeHTML from \"./scopeHTML.js\";\n\nlet tags;\nlet\tsuffix;\n\nconst setTags = t => {\n\ttags = t;\n};\nconst setSuffix = s => {\n\tsuffix = s;\n};\n\nconst litRender = (templateResult, domNode, styles, { eventContext } = {}) => {\n\tif (styles) {\n\t\ttemplateResult = html`<style>${styles}</style>${templateResult}`;\n\t}\n\trender(templateResult, domNode, { eventContext });\n};\n\nconst scopedHtml = (strings, ...values) => html(scopeHTML(strings, tags, suffix), ...values);\nconst scopedSvg = (strings, ...values) => svg(scopeHTML(strings, tags, suffix), ...values);\n\nexport { setTags, setSuffix };\nexport { scopedHtml as html, scopedSvg as svg };\nexport { repeat } from \"lit-html/directives/repeat.js\";\nexport { classMap } from \"lit-html/directives/class-map.js\";\nexport { styleMap } from \"lit-html/directives/style-map.js\";\nexport { unsafeHTML } from \"lit-html/directives/unsafe-html.js\";\n\nexport default litRender;\n","import {\n\tAttributePart,\n\tdirective,\n\tnoChange,\n} from \"lit-html/lit-html.js\";\n\n/*\n\tlit-html directive that removes and attribute if it is undefined\n*/\nexport default directive(value => part => {\n\tif ((value === undefined) && part instanceof AttributePart) {\n\t\tif (value !== part.value) {\n\t\t\tconst name = part.committer.name;\n\t\t\tpart.committer.element.removeAttribute(name);\n\t\t}\n\t} else if (part.committer && part.committer.element && part.committer.element.getAttribute(part.committer.name) === value) {\n\t\tpart.setValue(noChange);\n\t} else {\n\t\tpart.setValue(value);\n\t}\n});\n"],"names":["directives","WeakMap","directive","f","d","set","isDirective","o","has","isCEPolyfill","window","customElements","undefined","polyfillWrapFlushCallback","reparentNodes","container","start","end","before","n","nextSibling","insertBefore","removeNodes","removeChild","noChange","nothing","marker","String","Math","random","slice","nodeMarker","markerRegex","RegExp","boundAttributeSuffix","Template","result","element","parts","nodesToRemove","stack","walker","document","createTreeWalker","content","lastPartIndex","index","partIndex","strings","length","values","node","nextNode","currentNode","pop","nodeType","hasAttributes","attributes","count","i","endsWith","name","stringForPart","lastAttributeNameRegex","exec","attributeLookupName","toLowerCase","attributeValue","getAttribute","removeAttribute","statics","split","push","type","tagName","data","indexOf","parent","parentNode","lastIndex","insert","s","createMarker","match","createTextNode","previousSibling","str","suffix","isTemplatePartActive","part","createComment","TemplateInstance","template","processor","options","__parts","setValue","commit","fragment","cloneNode","importNode","nodeIndex","nodeName","handleTextExpression","insertAfterNode","handleAttributeExpressions","adoptNode","upgrade","commentMarker","TemplateResult","l","html","isCommentBinding","commentOpen","lastIndexOf","attributeMatch","substr","createElement","innerHTML","getHTML","SVGTemplateResult","svgElement","firstChild","isPrimitive","value","_typeof","isIterable","Array","isArray","Symbol","iterator","AttributeCommitter","dirty","_createPart","AttributePart","text","v","t","setAttribute","_getValue","committer","NodePart","__pendingValue","startNode","appendChild","endNode","ref","__insert","__commitText","__commitTemplateResult","Node","__commitNode","__commitIterable","clear","valueAsString","templateFactory","update","instance","_clone","itemParts","itemPart","item","appendIntoPart","insertAfterPart","BooleanAttributePart","Error","PropertyCommitter","single","PropertyPart","eventOptionsSupported","capture","addEventListener","removeEventListener","_e","EventPart","eventName","eventContext","__boundHandleEvent","e","handleEvent","newListener","oldListener","shouldRemoveListener","once","passive","shouldAddListener","__options","getOptions","event","call","DefaultTemplateProcessor","prefix","defaultTemplateProcessor","templateCache","templateCaches","get","stringsArray","keyString","Map","key","join","getTemplateElement","render","Object","assign","appendInto","svg","cache","scopeHTML","tags","map","string","forEach","tag","replace","createAndInsertPart","containerPart","beforePart","beforeNode","newPart","updatePart","insertPartBefore","removePart","generateMap","list","partListCache","keyListCache","repeat","items","keyFnOrTemplate","keyFn","oldParts","oldKeys","newParts","newValues","newKeys","newKeyToIndexMap","oldKeyToIndexMap","oldHead","oldTail","newHead","newTail","oldIndex","oldPart","classMapCache","classMap","classInfo","className","classList","oldInfo","remove","method","styleMapCache","styleMap","styleInfo","style","cssText","removeProperty","setProperty","previousValues","unsafeHTML","previousValue","setTags","setSuffix","litRender","templateResult","domNode","styles","scopedHtml","scopedSvg"],"mappings":"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A;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IACA,WAAO6L,OAAO,IAAIC,OAAX,IAAsBC,OAAO,IAAIC,OAAxC,EAAiD;IAC7C,UAAIV,QAAQ,CAACO,OAAD,CAAR,KAAsB,IAA1B,EAAgC;IAC5B;IACA;IACAA,QAAAA,OAAO;IACV,OAJD,MAKK,IAAIP,QAAQ,CAACQ,OAAD,CAAR,KAAsB,IAA1B,EAAgC;IACjC;IACA;IACAA,QAAAA,OAAO;IACV,OAJI,MAKA,IAAIP,OAAO,CAACM,OAAD,CAAP,KAAqBH,OAAO,CAACK,OAAD,CAAhC,EAA2C;IAC5C;IACAP,QAAAA,QAAQ,CAACO,OAAD,CAAR,GACIpB,UAAU,CAACW,QAAQ,CAACO,OAAD,CAAT,EAAoBJ,SAAS,CAACM,OAAD,CAA7B,CADd;IAE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"}
